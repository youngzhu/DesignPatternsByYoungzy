# [译文]责任链模式

> 原文网址：[Chain of Responsibility Design Pattern](https://sourcemaking.com/design_patterns/chain_of_responsibility)

## 意图
- 通过多个对象处理请求的方式来避免请求的发送方和接收方的耦合。将接收方串联起来，并将请求在这个链上传递直到请求被处理。
- 用一个包含了多个处理器的处理管道发送或者处理请求。
- 一个递归遍历的面向对象的链表

## 问题
可能有很多数量的“处理器”“处理单元”或者“节点”，还有一个必须被处理的请求流。需要在没有固定关系或优先级或请求与处理器映射关系的情况下有效地处理请求。

![](https://sourcemaking.com/files/v2/content/patterns/Chain_of_responsibility1.png)

## 讨论
将各处理器封装在一个抽象的管道里，客户端在管道的入口处发起请求。

![](https://sourcemaking.com/files/v2/content/patterns/Chain_of_responsibility_1.png)

这种模式将接收对象连在了一起，然后将请求消息逐个传递直到某个接收对象可以处理这个消息。处理器对象的数量和类型不是确定好的，他们可以被动态地设置。
这种链式结构使用递归允许无数的处理器被链接。

责任链简化了对象之间彼此的联系。不用在发送者和接收者维护可能存在的联系，每个发送者只需要关联链表的头部，每个接收者只需要一个它的“继承者”的引用。

确保有一个“安全网”能够捕获任何未能被处理的请求。

以下场景中不要使用责任链模式：每个请求只需要被一个处理器处理；客户端知道哪个处理器应该处理当前的请求。

## 结构
派生类知道如何满足客户端的请求。如果当前的对象（接收器）不可用或不能满足，就将它委托给基类，基类再委托给下一个接收器，循环继续。

![](https://sourcemaking.com/files/v2/content/patterns/Chain_of_responsibility__.png)

多处理器使得能够处理每一个请求。请求可能被传递到链的末端，所以要小心不要委托给一个空对象。

## 举例
ATM在取钱机制中使用了责任链模式。

![](https://sourcemaking.com/files/sm/images/patterns/Chain_of_responsibility_example.png)

## 核查清单（也可以理解为应用步骤）
1. 基类维护了一个“next”指针
2. 每一个派生类都促成了请求的处理
3. 如果这个请求需要被传递下去，当前的处理器就要回调基类，以便于委托给“下一个”处理器
4. 客户端（或第三方）创建并形成链（有些可能需要将最后的节点链回根节点）
5. 客户端从链的根部发起请求
6. 递归创造了这种魔术般的幻觉

