# [译文]状态模式

> 原文网址：[State Design Pattern](https://sourcemaking.com/design_patterns/state)

## 意图
- 允许一个对象在它的内部状态发生改变时改变它的行为。对象好像改变了它的类
- 一个面向对象的状态机
- 封装（状态机）+多态的状态类+协作

## 问题
一个对象的行为是一个基于状态的函数，它的行为必须在运行是随着状态的改变而改变。
或者，一个应用程序基于它的状态拥有大量的条件语句去控制它的流程。

## 讨论
状态模式是如何让行为依赖与状态这一问题的解决方案。

- 定义一个“上下文”类作为对外的唯一接口
- 定义一个状态的基类
- 定义不同的状态类，作为状态基类的衍生类
- 在“上下文”类中维护一个当前状态的引用
- 改变状态的同时，改变“当前状态”这个引用

状态模式并不指定状态的流转应该被定义在哪里。有两个选择：在“上下文”类中，或者在各自的状态类中。
后者的优势是很容易增加新的状态类。缺点是每一个状态类会和其他的“手足”类产生耦合，增加了子类之间的依赖。

以表驱动的方式去设计有限状态机很好地定义了状态间的转换，但是很难随着状态的变化而变化。
基于状态模式的方式是使用代码（而不是数据结构）去指定状态的改变，这能很好地适应状态的改变。

## 结构
状态机的接口被封装在 `Context` 类中。 `State` 的接口跟 `Context` 的一样，只是多了一个参数。
这个多的参数可以使 `State`类在需要的时候回调 `Context` 类。
复杂性——可能会拖累`Context` 类——被尽量地分隔并封装在`State`类中。

![](https://sourcemaking.com/files/v2/content/patterns/State1.png)

## 举例
这种模式可以在自动售货机上观察到。自动售货机的状态基于库存、投入的硬币数量、找零、选中的货物等等。
当投入硬币并做出选择后，售货机可能递出货物而没有零钱，或者递出货物和零钱，或者因为投入的硬币不足而不递出货物，
或者因为货物售罄而不递出。

![](https://sourcemaking.com/files/v2/content/patterns/State_example1.png)

## 核查清单（也可以理解为应用步骤）
1. 找出一个已有的类，或新建一个，从调用者的角度看它是作为“状态机”提供服务的
2. 创建一个状态基类，复制“状态机”中的方法。每个方法都多了一个参数：状态机实例。这个状态基类可以指定一些默认的行为
3. 创建具体的状态类。这些衍生类只覆盖必要的方法
4. 状态机有一个表示当前状态的“状态类”引用
5. 所有的客户端请求都委托给当前状态对象，状态机本身用 `this` 传递过去
6. 在状态类中将状态机的状态改为合适的状态

## 经验法则
- 状态模式和桥接模式的结构是一样的，除了桥接模式中封装类是多层结构，而状态类只有一个。这两种模式用相同的结构解决不同的问题：
状态模式运行对象的行为随着它的状态而改变；而桥接是为了将抽象和实现之间解耦，实现相对独立。
- 状态模式是在策略模式的基础上实现的。它们的区别在于意图。策略模式，对算法的选择是相当稳定的。
而状态模式，状态机状态的改变导致了对策略对象（不同的状态对象）的选择。