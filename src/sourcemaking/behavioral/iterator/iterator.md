# [译文]迭代器模式

> 原文网址：[Iterator Design Pattern](https://sourcemaking.com/design_patterns/iterator)

## 意图
- 提供一个依次访问一个集合对象中各个元素的方法，同时不会暴露其底层的实现
- C++和Java的标准库的抽象性使得集合类和其算法分离成为可能
- 将对集合的遍历变成它的一种状态（特性）
- 多态的遍历

## 问题
需要能抽象地遍历完全不同的数据结构，所以算法要设计成能够透明地交互。

## 讨论
“一个集合对象，如列表，应该提供一个访问其元素的方式，并且不会暴露它的内部结构。此外，你可能想要不同的方式去遍历这个列表，
这取决于你想做什么。但是你可能不想增加一些不同的遍历接口使其变得臃肿，即使你预见到你可能会用到。
对同一个列表，你可能需要一个以上的遍历方法。”所以，为不同类型的集合对象提供一个统一的遍历接口是很有价值的。

迭代器模式能让你做到这些。其核心思想是承担起访问和遍历集合对象的职责，将它放入一个提供了标准遍历接口的迭代器对象中。

迭代器的抽象性是一个名为“泛型编程”的新兴技术的基础。这种策略旨在明确区分算法和数据结构。
动机是：促进基于组件的开发，提高开发效率，减少配置管理。

举个例子，如果你要支持四种数据结构（数组、二叉树、链表和哈希表）和三种算法（排序、查找和合并），
传统的方法需要4X3的排列组合去开发和维护。但是泛型编程只需要4+3个配置项。

## 结构
客户端直接使用集合类的公共方法。但是对集合元素的遍历是封装在被称为迭代器的附加的抽象层里。
每一个集合的衍生类都知道应该生成和返回什么样的迭代器。客户端依赖于迭代器基类提供的方法。

![](https://sourcemaking.com/files/v2/content/patterns/Iterator.png)

## 举例
文件是集合对象。在办公室，是通过行政或者秘书来访问文件，秘书作为迭代器展示了迭代器模式。
有些电视情景喜剧在主管允许的情况下正在尝试理解秘书的文件系统。对主管而言，文件系统混乱且不合逻辑，
但秘书又能够快速高效地查找文件。

早期的电视机是用转盘来切换频道。当浏览频道时，观看者需要转动转盘使其对应到频道所在位置，不管这个频道是否被接收过。
现代的电视机，使用了“上一个”、“下一个”按钮。当观看者选择了“下一个”按钮，下一个频道的节目就会显示。
想象一下，你在一个陌生城市的酒店里。在浏览电视节目时，频道的数字不重要，内容才重要。如果某个频道的节目不感兴趣，
你可以看下一个频道，不需要知道它的频道号。

![](https://sourcemaking.com/files/v2/content/patterns/Iterator_example1.png)

## 核查清单（也可以理解为应用步骤）
1. 给集合类增加一个 createIterator() 方法，并授予迭代器访问的权限
2. 设计一个迭代器类，能够封装对集合类的遍历
3. 客户端从集合类获取一个迭代器
4. 客户端使用迭代器的 first(), isDone(), next(), currentItem() 方法访问集合类中的元素

