# [译文]解释器模式

> 原文网址：[Interpreter Design Pattern](https://sourcemaking.com/design_patterns/interpreter)

## 意图
- 给定一种语言，定义它的语法格式和解释器，该解释器使用其格式解释其句子
- 将一个领域映射为一种语言，从语言再到语法，从语法到分层的面向对象设计

## 问题
有一类问题在定义良好且沟通良好的领域重复地出现。
如果这个域具有一种语言特征，那么这类问题就可以轻松地通过一种翻译引擎来解决。

## 讨论
解释器模式讨论的是：用简单的语法定义一种领域语言（如问题特征），一种语法规则，还有为了解决问题而对句子的解释。
这个模式用一个类去展现每一种语法规则。而且因为语法在结构中通常是多层的，规则类的继承关系被映射的很好。

一个抽象的基类定义了一个 interpret() 方法。每一个具体的类实现了这个方法，以参数的形式接收当前语言流的状态，
并加快问题的解决过程。

## 结构
解释器建议使用递归的语法为领域建模。每一条语法规则也是一个“组件”（跟其他的语法有关联）或者是一个终点（树结构的叶子节点）。
解释器依赖于组合模式的递归遍历来解释请求处理的“句子”。

![](https://sourcemaking.com/files/v2/content/patterns/Interpreter1.png)

## 举例
解释器模式定义了一种语言的语法形式和一个解释该语法的解释器。
音乐家就是个例子。音调和音阶可以在乐谱上用音符表示。这些音符给音乐提供了一种语言。
音乐家演奏音乐时可以重现每个音符原始的音调和音阶。

![](https://sourcemaking.com/files/v2/content/patterns/Interpreter_example1.png)

## 核查清单（也可以理解为应用步骤）
1. 判断一个“小语法”是否有合理的回报
2. 定义这种语法
3. 将每一个语法映射成一个类
4. 将这一组类组织成组合模式的结构
5. 在组合模式的继承关系中定义一个解释方法 `interpret(Context)`
6. `Context` 类封装了输入和输出的当前状态，前者被处理，后者被累积。它被每个语法类的“解释”过程从输入转化为输出。

## 经验法则
- 考虑其最基本的形式，即一种操作被分布在基于复合模式的类层次结构上，几乎每一个复合模式都会包含解释器模式。
但如果你要把这种类结构当做对一种语言的定义，解释器模式就应该被保留。
- 该模式不能用于地址解析。如果语法过于复杂，其他的技术（如解析器）可能更适合。
