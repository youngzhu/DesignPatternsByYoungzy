# [译文]观察者模式

> 原文网址：[Visitor Design Pattern](https://sourcemaking.com/design_patterns/visitor)

## 意图
- 描绘了一种在一个对象的各元素上执行的操作。观察者模式可以在不改变原对象的情况下增加新的操作。
- 恢复类型信息丢失的典型技术。
- 在同一类型的不同对象上做正确的事情
- 双重分发

## 问题
许多不同的彼此无关的操作需要在异构的聚合的节点对象上执行。你不想因此而“污染”这些节点对象。
而且你也不想遍历每一个节点，然后将它们转换成执行这个操作所需要的类型。

## 讨论
观察者模式主要的目的是对应用在聚合的元素对象上的操作的一种抽象。
这种方式鼓励设计轻量级的元素类，因为“处理方法”已经从它们的职责中去除了。
新的功能可以通过增加一个新的观察者类来轻松地添加。

观察者模式实现了“双重分发”。面向对象的消息通常都体现了“单一分发”——所有操作的执行依赖于请求的方法和接收者的类型。
而在“双重分发”中，操作的执行依赖于请求的方法和“两种”接收者的类型——观察者的类型和它所观察的元素的类型。

这种实现有其益处。创建一个访问者的类结构，在抽象的基类中定义一个纯虚拟的 visit() 方法，在聚合的节点对象的结构中使用具体的衍生类。
每个 visit() 方法都有一个唯一的参数——原始节点对象的指针或引用。

每一个可执行的操作都被封装在一个具体的Visitor衍生类中。在基类中定义的 visit() 方法在具体的子类中根据“类型查询和转换”被适当地重载了。

在被观察对象结构的基类中添加一个纯虚拟的 accept() 方法。该方法有唯一的参数——观察者基类的指针或引用。

每一个具体的被观察者类实现的 accept() 方法只是简单地调用它对应的观察者的 visit() 方法，并把它自己作为唯一参数传递。

被观察者和观察者都被设定好了。当客户端需要执行一个操作，创建一个观察者实例，调用被观察者的 accept 方法，并把这个观察者传递过去。

accept 方法的控制流去查找正确的被观察者对象。然后调用 visit 方法，该方法会指向正确的观察者。
accept 分发加上visit分发就是双重分发。

观察者模式使得添加一个新的操作或功能变得容易——只要新增一个观察者对象。
但是，如果被观察者的结构不稳定，那么要保持观察者结构的同步就会很困难。

反对访问者模式的一个观点是它代表了功能性拆分的一种回归——将算法和数据结构分离。
虽然这是一个合理的解释，但一个更好的角度或者理由可能是将非传统行为变成对象状态的目标。

## 结构
被观察者是一个具有“通用适配方法”的系统。每一个衍生类实现的 accept 方法都是一样的。
但是它不能放在基类中而被所有子类继承，因为它有一个 this 的引用参数。

![](https://sourcemaking.com/files/v2/content/patterns/Visitor1.png)

多态的 firstDispatch 方法被调用时，具体的类将覆盖基类。
多态的 secondDispatch 方法被调用时，具体的类也将覆盖其基类。
适合这种模式的程序功能可以应用了。

![](https://sourcemaking.com/files/v2/content/patterns/Visitor_1.png)

## 举例
这种模式可以在出租车公司观察到。当一个人给出租车公司打电话（接受一个观察者），公司给客户分派一辆出租车。
一旦上车，这个客户或者出租车公司就不能控制客户的行程了，出租车司机可以。

![](https://sourcemaking.com/files/v2/content/patterns/Visitor_example1.png)

## 核查清单（也可以理解为应用步骤）
1. 确认当前的结构（被观察者）是非常稳定的，并且它提供了足够的观察者需要的接口。如果这些条件不满足，观察者模式就不是一个好选择。
2. 在观察者Visitor基类中为每一个被观察者类定义一个 visit(ElementXXX) 方法
3. 在观察者的结构中添加一个 accept(Visitor) 方法，每一个衍生类中的实现都是一样的 `accept(Visitor v){v.visit(this)} `。
由于循环依赖，观察者类和被观察者类需要交叉。
4. 被观察者只与观察者的基类耦合，而观察者会与每一个具体的被观察者耦合。如果被观察者的结构不稳定，而观察者比较稳定，就考虑将他们的角色互换一下。
5. 为被观察者的每一个不同的操作创建一个观察者衍生类。 visit()  方法的实现依赖与被观察者的接口
6. 客户端创建观察者类，并把被观察者通过 accept() 方法传入。

## 经验法则
- 访问者模式是典型的不用动态转换而能恢复丢失的类型信息的技术。

## 说明
2000年11月詹姆斯·库柏（《Java设计模式指南》一书的作者）在JavaPro上发布了一篇关于观察者模式的文章。
他建议道：将我们面向对象的模型改为表驱动的，并创建新的类来执行其他类中的数据……虽然这可能会显得不太清晰……但是有理由这么做。

他举了一个例子。假设你有一个员工-工程师-老板的结构关系。他们都享受正常的假期政策，但是老板会有额外的假期。
所以，老板的接口类跟工程师的类是不同的。我们不能以多态的方式遍历一个想组合一样的组织去计算这个组织剩余的总的假期天数。
“如果许多类有不同的接口，我们想要封装从这些类中获取数据的方式，这时观察者模式就会很有用”。

他使用观察者模式获得的好处有：
- 可以给既没有源码也不能改变代码的类库添加新的功能
- 可以从一个不同组且不相关的类中获取数据，并且可以将它作为全局的计算结果提供给客户程序
- 收集相关操作形成一个类，而不是迫使你去改变或新增衍生类来添加新的操作
- 与复合模式合作

当被观察者类结构不稳定时观察者模式是不合适的。每增加一个被观察者，所有的观察者类都要增加。