# [译文]命令模式

> 原文网址：[Command Design Pattern](https://sourcemaking.com/design_patterns/command)

## 意图
- 将请求封装为对象，从而可以让你将客户的不同请求参数化，包括队列或日志请求，并支持可撤销的操作。
- 促使“调用一个对象的一个方法”变成该对象的所有（且唯一）状态
- 面向对象的一次返祖（面向函数）

## 问题
需要在不知道请求的具体操作或请求的接收者的情况下发起请求。

## 讨论
命令模式将操作的调用和执行解耦。要实现这样的分离，设计者创建了一个抽象的基类映射接收者（一个对象）和一个动作（一个指向成员方法的指针）。
这个基类包含了一个 `execute()`方法用来调用接收者的成员方法。

所有命令对象的调用者将每一个对象都当做一个“黑盒”，在需要对象提供服务的时候只要调用它的 `execute()` 方法就行了。

一个命令对象类包含以下内容（部分或全部）：一个对象，一个使用这个对象的方法，以及调用这个方法时需要的参数。
命令对象的`execute()` 方法将这些内容聚集在一起。

一系列的命令对象可以组合成复合命令或宏命令。

## 结构
客户端创建一个命令和执行一个命令是不同的。这种分离在命令的时序上提供了灵活性。
将命令（方法）变成一个对象意味着它可以被传递、被暂存、被共享、被加载在一个表格里，换句话说就是可以想其他对象一样使用。

![](https://sourcemaking.com/files/v2/content/patterns/Command.png)

命令对象可以被当成由一个知道需要干啥什么的委托人创建的一组令牌，然后传递给另一个能够处理它的委托人。

## 举例

菜馆里的“点菜单”是命令模式的一个例子。服务员从顾客那获得点单，然后通过写在纸上的方式封装它。
之后这个订单会被放到某个快餐厨师的订单队列中。注意，服务员使用的点菜本不依赖于菜单，所以他们可以
接受很多不同订单。

![](https://sourcemaking.com/files/v2/content/patterns/Command_example1.png)

## 核查清单（也可以理解为应用步骤）
1. 定义一个命令接口，里面包含一个方法，例如 `execute()`
2. 创建一个或多个衍生类，包含以下部分：一个接收对象，需要调用的方法和需要传递的参数
3. 为每个延迟执行的请求初始化一个命令对象
4. 将命令对象从创建者（即发送者）传递给调用者（即接收者）
5. 接收者决定什么时候去执行

## 经验法则
- 命令模式两个重要的方面：接口分离（发送者和接收者之间是独立的）；时序分离（存储需要处理的请求稍后执行）

