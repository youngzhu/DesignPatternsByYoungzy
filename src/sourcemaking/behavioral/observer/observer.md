# [译文]观察者模式

> 原文网址：[Observer Design Pattern](https://sourcemaking.com/design_patterns/observer)

## 意图
- 有一组一对多的依赖关系，当一个对象的状态改变时，它所有的依赖对象都会被通知到并自动更新。
- 将核心（或通用或引擎）组件封装在抽象的“主体”类中，将变量（或可选的或用户行为）组件封装在“观察者”类中。
- MVC模式中的“视图”模块

## 问题
大型的单片机设计已经不能满足对新的图形和监控的扩展需求了。

## 讨论
定义一个对象，作为数据模型和（或）业务逻辑的“管理人”，即主体类。
将所有“视图类”的功能都委托给解耦的、不同的观察者对象。
观察者们在创建自身时就注入了主体类。当主体类改变时，它就向所有注册过的观察者发通知告诉它们有变化发生，
然后每个观察者根据自身的监控职责从主体类中获取相关状态。

这就使得主体类的状态和观察者们可以动态配置，而不是在编译阶段就指定。

以上描述的方法指出了一个“拉取”的互动模式。每一个观察者根据自己的职责从主体类中获取变化，
而不是由主体类将它的变化“推送”给所有的观察者。
“推送”模式易于重用，而“拉取”模式相对低效。

上面的讨论，留给设计师去权衡，包括：事件压缩（在一系列变化发生后只发送单个变化的通知广播）、
一个观察者监控多个主体、在一个主体即将消失时确保能通知到它的观察者们。

MVC结构在Smalltalk社区已存在多年，而观察者模式吸取了MVC的精髓。

## 结构

![](https://sourcemaking.com/files/v2/content/patterns/Observer.png)

主体类代表了核心（或独立的、或通用的、或关键的）功能的抽象。
观察这代表了变量（或依赖的、或可选的、或用户操作的）的抽象。
主体提示观察者们去做自己的事。每一个观察者都可以在需要的时候回调主体。

## 举例
一些拍卖活动展示了这种模式。
每个投标人都有一个标着数字、代表了报价的牌子。
拍卖师开始拍卖，当一个牌子被举起表示接受这个出价时，他就被当成了一个“观察者”。
通过这样的形式，每一轮新的报价都会被告知给所有投标者。

![](https://sourcemaking.com/files/v2/content/patterns/Observer_example1.png)

## 核查清单（也可以理解为应用步骤）
1. 区分出核心（或独立）功能和可选（或依赖性的）功能
2. 将核心功能抽象成一个主体类
3. 将依赖性的功能抽象成观察者类
4. 主体类只与观察者类的基类耦合
5. 客户端决定主体的状态和观察这的类型
6. 观察者们需要将他们自己注册到主体中
7. 主体将事件广播给所有注册过的观察者
8. 主体可能向观察者们推送消息，或者观察者们在需要的时候也可以从主体获取消息