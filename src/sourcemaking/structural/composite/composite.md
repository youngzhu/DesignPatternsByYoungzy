# [译文]复合模式

> 原文网址：[Composite Design Pattern](https://sourcemaking.com/design_patterns/composite)

## 意图
- 将对象复合成树形结构来表示“整体-部分”的层次结构。复合模式使客户端可以一致地对待单个对象和复合对象
- 递归复合
- 目录下包含条目，可能每一个条目都是目录
- 一对多的“has-a”结构变为“is-a”结构

## 问题
应用程序需要处理包含原始对象和复合对象的分层集合。处理原始对象是一种方式，处理复合对象是另一种方式。每次在处理前都要查一下对象所属的类型是不可取的。

## 讨论
定义一个抽象的基类（组件类）并指定原始对象和复合对象都会执行的方法。原始对象和复合对象都继承自组件类。只有当管理自己的“孩子”时，复合类才去关联抽象基类。

复合对象包含组件，组件又是复合对象的时候，可以使用这种模式。

通常，管理“孩子”的方法（如 `addChild()` `removeChild()`）应该被定义在复合对象里。不幸的是，统一地对待原始对象和复合对象的需求使得这些方法必须移到抽象基类里。参见下方“观点”里关于“安全性”和“透明度”的讨论。

## 结构
复合对象包含组件，每一个组件有可能是个复合对象。

![](https://sourcemaking.com/files/v2/content/patterns/Composite.png)

菜单包含子菜单，子菜单有可能包含子菜单。

行-列类的GUI布局管理器包含小组件，每个小组件可能也是一个行-列布局管理器。

文件夹下包含文件夹。

容器里包含元素，每个元素可能也是个容器。

## 举例
尽管这个例子是抽象的，但数学表达式是一个复合对象。一个数学表达式包含一个运算对象，一个操作符（加减乘除），再有另一个运算对象。运算对象可能是一个数字，也可能是一个数学表达式。所以，`2+3` 和 `(2+3)+(4*6)` 都是有效的表达式。

![](https://sourcemaking.com/files/v2/content/patterns/Composite_example1.png)

## 核查清单（也可以理解为应用步骤）
1. 确认你的问题是关于“整体-部分”的层次结构的
2. 考虑这样的场景：容器里包含元素，每个元素可能也是个容器。例如，集合里包含对象，每个对象可能也是个集合。把你的问题对应到这样的例子里。
3. 创建最低限度的共通性接口，使得容器和元素可以互换。它应该定义了容器类和元素类都能无差别执行的方法。
4. 所有的容器类和元素类同接口之间是“is-a”的关系
5. 所有的容器类和接口类形成了一个“一对多”的“has-a”的关系
6. 容器类利用多态性将责任委托给元素类
7. 将管理“孩子”的方法（如 `addChild()` `removeChild()`）放到抽象基类里

## 观点
复合模式的要点是可以自动处理组件。如果你想增加一个迭代的功能，没问题。但个人觉得，这超出了模式本身的范围。该模式的核心功能让客户端在处理一个对象时不需要知道里面是否包含了很多对象。

要想统一地处理混杂的对象集合需要把管理子组件的接口定义在组件基类里。但是这会破坏安全性，因为客户端可以做些毫无意义的事情，如给叶子组件添加或删除对象。如果为了安全考虑，把管理子组件的接口定义在派生组件类中，就失去了透明性，因为叶子组件和其他组件有了不同的接口。

Smalltalk在实现复合模式时通常将管理组件的接口定义在复合对象中，而不是基类中。C++更倾向于将其放在基类中。这一点非常有趣，也精彩让我陷入沉思。我可以用一些理论来解释，但没人能确定它就是正确的。

组件对象（基类）不知道复合对象的存在。他们不会给操作复合对象有所帮助，也不会对修改复合对象有帮助。这是因为我希望所有的类（包括衍生类）在不需要复合对象时就可以重复使用。对于某个给定的对象引用，如果我确实需要知道它是否是一个复合对象，我会使用强制转换。如果强制转换的代价太高昂，我会使用观察者模式。

常见的一个抱怨是：如果把复合接口改为复合类，怎么去遍历一个复杂的结构？我的回答是当我要的行为满足复合模式的层次结构时，我通常会使用观察者模式。所以遍历不是问题——观察者知道它正在处理的是哪一类对象。观察者模式不需要每一个对象都提供一个遍历接口。

复合模式没有强制要求把所有的组件都当做复合对象。它仅仅是说把那些需要统一对待的操作放在基类里。如果添加、删除和其他类似操作不能或者不允许统一对待，那就不要把他们放在基类中。还要记住，我们的模式结构图不是用来定义模式的，它仅仅是将我们的一种实现表现在其中。就像这里的复合模式的结构图显示对子组件的管理操作被定义在基类里，但这不代表所有的实现都要这么做。

Component  组件对象  
Composite  复合对象