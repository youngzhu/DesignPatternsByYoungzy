# [译文]代理模式

> 原文网址：[Proxy Design Pattern](https://sourcemaking.com/design_patterns/proxy)

## 意图
- 为另一个对象的访问提供一个代理或占位符
- 使用一个额外的间接层提供分布式的，或受约束的，或智能的访问控制
- 增加一个封装类并使用委托来隐藏真实组件过度的复杂性

## 问题
你需要资源消耗大的对象，但在客户端发起真正的请求前你不想初始化它们。

## 讨论
设计一个替代品或代理：在客户端第一次发起的请求时初始化真正的对象；记得这个真实对象的身份；将最初的请求转发给真实的对象。之后所有的请求都简单而直接地转发给被封装的真实的对象。

以下四个常见的场景适用代理模式：
1. 虚拟代理是创建时消耗很大的对象的占位符。真实的对象只在客户端第一次请求或访问时创建。
2. 远程代理为存在于不同地址空间的对象提供了一个本地的代表。这也正是 `PRC` 和 `CORBA` 中的 `stub` 所提供的。
3. 保护型的代理控制对敏感的原始对象的访问。这个代理对象验证调用者是否有必要的访问权限再去转发这个请求。
4. 在对象被访问时，智能的代理可以调停其他的一些动作。典型的应用包括：
    - 统计真实对象的引用个数，在没有引用时可以自动释放（也叫智能指针）
    - 将一个持久化的对象在它第一次被引用时加载进内存
    - 在访问真实对象之前验证其是否被锁了，以保证没有其他对象可以修改它。

## 结构
通过定义一个主题接口，代理对象代替了真实对象的位置，使得真实对象对客户端来说是透明的。

![](https://sourcemaking.com/files/v2/content/patterns/Proxy1.png)


## 举例
支票或汇票就是一个账户里资金的代理。支票可以替代现金做支付，实际上是在控制发行人的现金账户。

![](https://sourcemaking.com/files/v2/content/patterns/Proxy_example1.png)

## 核查清单（也可以理解为应用步骤）
1. 确定杠杆或切面，最好是用封装类或代理来实现
2. 定义一个接口使得代理类和真实类可以互相替换
3. 考虑定义一个工厂类来决定是使用代理类还是真实类
4. 封装类包含一个真实类的引用并实现了步骤二中的接口
5. 真实对象可以在构造函数或是第一次使用时初始化
6. 封装类发挥它的杠杆作用，并调用真实对象