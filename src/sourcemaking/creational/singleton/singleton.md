# 单例模式

> 原文网址：[Singleton Pattern](https://sourcemaking.com/design_patterns/singleton)

## 意图
- 确保一个类只存在一个实例，并供全局访问
- 适时初始化，或者在第一次使用时初始化

## 问题
应用需要一个，并且只需要一个对象的实例。还有，延迟初始化和全局访问是必要的。

## 讨论
单例的职责有：创建、初始化，访问和执行。声明一个私有的、静态的成员变量；提供一个公共的、静态的方法来封装初始化代码，并返回该实例。

客户端可以随时调用这个静态方法来获取单例。

只有在同时满足一下三个条件时才考虑使用单例模式：
1. 单例的控制权不会被回收，即使是合理的回收
2. 延迟初始化是合适的
3. 其他地方没有提供全局访问

如果不能控制单例何时以及如何被初始化，不能被全局访问，单例模式就没那么大吸引力了。

单例模式可以被扩展为支持应用指定数量的实例。

“静态的成员方法”这种方式不支持子类。

删除一个单例也不是什么大问题。详见[《消除单例》](https://sourcemaking.com/design_patterns/to_kill_a_singleton)。

## 结构
![](https://sourcemaking.com/files/v2/content/patterns/singleton1.png)

单例的类是可以直接访问的，并且在第一次使用时初始化。
单例实例是私有的、静态的属性。获取单例的方法是公共的、静态的方法。

![](https://sourcemaking.com/files/v2/content/patterns/Singleton.png)

## 举例
美国的总统办公室是一个单例。美国的宪法规定了总统的选举、任期和继任的章程。任何时间只会有一个现任总统。不管现任总统的个人身份是什么，在全球范围内“美国总统”指代的就是坐在那个办公室里的人。

![](https://sourcemaking.com/files/v2/content/patterns/Singleton_example1.png)

## 核查清单（也可以理解为应用步骤）
1. 在实现单例的类里定义一个私有的、静态的变量
2. 相同的类里，定义一个公共的、静态的方法访问这个变量
3. 在这个静态方法中实现“延迟初始化”（在第一次使用时初始化）
4. 将该类的构造函数定义成 `protected` 或 `private`
5. 客户端仅通过第2步中的公共方法使用单例

## 经验法则
- 在实现抽象工厂模式、构造器模式和原型模式时可以使用单例
- 门面模式通常是单例的，因为只需要一个“门面”
- 状态模式通常是单例的
- 作为全局变量的“单例”的优势是你能精确掌握实例的数量，如果你想的话，可以管理任意数量的实例
- 单例模式是被误用最多的模式。当一个类有且仅有一个实例时才应该使用单例。设计师经常错误地用单例去替换全局变量。总而言之，单例是一个全局变量。单例没有废除“全局”的概念，仅仅是另一种表达。
- 什么时候单例是不必要的？简单来说，是大部分时候。当传递一个对象引用比把它设为全局变量更简单的时候。单例模式的真正问题在于它给了你一个好的借口——不用仔细地考虑对个对象合适的可见性。找到正确的“暴露-保护”的平衡是维持灵活性的关键。
- 我们团队在使用全局变量时有一个坏习惯，所以我建了一个“单例”的研究小组。接着我就发现到处都是单例模式，而全局变量引起的问题并没有解决。解决全局变量问题的方法不是把它变成单例，而是要问问自己到底为什么要使用全局变量。改个名字并不能解决问题。事实上，可能更糟，因为你会说“我没用全局变量，而是用了单例”，尽管这两个是一回事。
