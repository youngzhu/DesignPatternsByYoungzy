# 原型模式（Prototype Pattern）

> 原文网址：[Prototype Pattern](https://sourcemaking.com/design_patterns/prototype)

## 意图
- 创建指定对象的原型实例，然后通过复制这个原型来创建更多的实例
- 指派一个类的一个实例用于育种该类的未来所有的实例
- `new` 操作是危险的

## 问题
应用程序在使用 `new` 操作时跟对象产生了“硬连接”（耦合）。

## 讨论
定义一个可供“克隆”的接口方法，维护一个包含所有“可克隆”的具体衍生类的“注册表”。每一个类都具有“多态性”：继承自基类或者接口，注册它的原型实例，实现了“克隆”方法。

作为客户端，不用再使用跟跟类名“硬连接”的 `new` 操作了，而是调基类的 `clone` 方法，通过字符串或者枚举值类型来指定具体的衍生类。

## 结构
工厂知道怎么找到正确的原型对象，各产品知道如何产生自己的实例。

![](https://sourcemaking.com/files/v2/content/patterns/Prototype.png)

## 举例
原型模式限定了可以使用原型实例创建的对象的类别。原型对象通常会提前构建好，这种情况下，原型是被动的，并不参与复制本身。细胞的有丝分裂——产生两个完全相同的细胞——是一个原型主动参与的例子，演示了原型模式。当一个细胞分裂时，得到了两个相同的细胞。也就是说，细胞复制了自身。

![](https://sourcemaking.com/files/v2/content/patterns/Prototype_example1.png)

## 核查清单（也可以理解为应用步骤）
1. 在现有的产品的继承关系中加上 `clone()` 方法
2. 设计一个“注册表”来维护原型对象。这个注册表可以封装在一个工厂类里，也可以放在产品基类里
3. 设计一个工厂方法：接受参数（也可以没有）；找到正确的原型对象；调用 `clone()` 方法；返回“克隆”结果
4. 用工厂方法替换所有的 `new` 操作

## 经验法则
- 当某个对象实例化过程比较昂贵时，原型是很有用的。为了方便，可以预备几个初始化的参数。这样，原型可以避免消耗高昂的“从头创建”，并支持从预加载的原型进行低开销的克隆。
- 原型模式是所有创建类设计模式中唯一一个不需要类只需要对象的模式（没太明白，原文是：doesn't require a class - only an object）。一些面向对象的编程语言，如 Self 和 Omega，完全使用原型来创建新的对象。